#!/usr/bin/python3

import argparse
import datetime
import calendar
import logging
import pprint
import json
import time
import sys
import os
import re

from datetime import datetime

import vjk

def get_loglevel(num):
    lvl_nums = {
        4: logging.DEBUG,
        3: logging.DEBUG,
        2: logging.INFO,
        1: logging.WARNING,
        0: logging.ERROR,
    }
    if num in lvl_nums:
        return lvl_nums[num]
    return logging.ERROR

parser = argparse.ArgumentParser(prog='vjk.py')

parser.add_argument('--conf', dest = 'conf',
                    default = 'conf/vjk.json',
                    help = 'configuration file in JSON format')

sp = parser.add_subparsers(dest = 'cmd')
for cmd in ['start']:
    spp = sp.add_parser(cmd, help = 'Start an activity. \
                        Format "activity@category,comment".')

for cmd in ['restart']:
    spp = sp.add_parser(cmd, help = 'Restart last activity.')

for cmd in ['stop']:
    spp = sp.add_parser(cmd, help = 'Stop the current activity if running.')

for cmd in ['list']:
    spp = sp.add_parser(cmd, help = 'List activities/categories')
    spp.add_argument('--category', dest = 'category',
                     help = 'Category mode', action = 'store_true')
    spp.add_argument('--summary', dest = 'summary',
                     help = 'Show summary time spent', action = 'store_true')
    spp.add_argument('--merge', dest = 'merge',
                     help = 'Merge same activities', action = 'store_true')
    spp.add_argument('--long', dest = 'long',
                     help = 'Long output for time records.', action = 'store_true')
    spp.add_argument('--start', dest = 'start',
                     help = 'Time to report from. Format [-|+]number[d|h|m])')
    spp.add_argument('--stop', dest = 'stop',
                     help = 'Time to report until. Format [-|+]number[d|h|m])')

for cmd in ['add']:
    spp = sp.add_parser(cmd, help = 'Add activities/categories')
    spp.add_argument('--category', dest = 'category',
                     help = 'Category mode', action = 'store_true')
    spp.add_argument('--start', dest = 'start',
                     help = 'Date and time activity started at. \
                     Format [YYYY-MM-DD] hh:mm:ss.')
    spp.add_argument('--tz-start', dest = 'tz_start',
                     help = 'Timezone offset in seconds on start.')
    spp.add_argument('--stop', dest = 'stop',
                     help = 'Date and time activity stopped at. \
                     Format [YYYY-MM-DD] hh:mm:ss.')
    spp.add_argument('--tz-stop', dest = 'tz_stop',
                     help = 'Timezone offset in seconds on stop.')

for cmd in ['edit']:
    spp = sp.add_parser(cmd, help = 'Edit activity/category')
    spp.add_argument('--category', dest = 'category',
                     help = 'Category mode', action = 'store_true')
    spp.add_argument('--start', dest = 'start',
                     help = 'Date and time activity started at. \
                     Format [YYYY-MM-DD] hh:mm:ss.')
    spp.add_argument('--tz-start', dest = 'tz_start',
                     help = 'Timezone offset in seconds on start.')
    spp.add_argument('--stop', dest = 'stop',
                     help = 'Date and time activity stopped at. \
                     Format [YYYY-MM-DD] hh:mm:ss.')
    spp.add_argument('--tz-stop', dest = 'tz_stop',
                     help = 'Timezone offset in seconds on stop.')
    spp.add_argument('--id', dest = 'id', help = 'Activity/category ID',
                     required = True)

for cmd in ['delete']:
    spp = sp.add_parser(cmd, help = 'Delete activity/category')
    spp.add_argument('--category', dest = 'category',
                     help = 'Category mode', action = 'store_true')
    spp.add_argument('--id', dest = 'id', help = 'Activity/category ID',
                     required = True)

for cmd in ['exit']:
    spp = sp.add_parser(cmd, help = 'Stop the server')

args, unknown_args = parser.parse_known_args()
if args.cmd == None:
    parser.print_help()
    sys.exit(1)

conf = []

if args.conf != None and os.path.isfile(args.conf):
    with open(args.conf) as f:
        conf = json.load(f)
else:
    if 'VJKCONF' in os.environ:
        with open(os.environ['VJKCONF']) as f:
            conf = json.load(f)
    else:
        logging.error("Provide server configuration")
        sys.exit(1)

if 'loglevel-client' not in conf:
    loglevel = logging.DEBUG
else:
    loglevel = get_loglevel(conf['loglevel-client'])

logging.basicConfig(format = '%(asctime)s %(filename)s %(funcName)s %(message)s',
                    datefmt = '%m/%d/%Y %H:%M:%S', level = loglevel)

logging.debug('Configuration')
logging.debug(pprint.pformat(conf))
logging.debug(pprint.pformat(args))

def reply_ok(reply):
    if reply:
        return reply.get('status') == 200
    return False

def reply_err(reply):
    if reply == None:
        logging.error("ERR: Reply is empty")
    else:
        logging.error("ERR: Reply status %s data %s" %
                      (reply.get('status', ""),
                       reply.get('data', "")))
    sys.exit(1)

def reply_verify_data(reply):
    if reply_ok(reply):
        if reply.get('data'):
            return True
        return False
    reply_err(reply)
    return False

def seconds_to_hms(seconds):
    h = seconds // 3600
    seconds -= h * 3600
    m = seconds // 60
    seconds -= m * 60
    return (h, m, seconds)

def unix_strftime_long(timestamp):
    if timestamp == None or timestamp == 0:
        return ''
    return datetime.utcfromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')

def unix_strftime_short(timestamp):
    if timestamp == None or timestamp == 0:
        return ''
    return datetime.utcfromtimestamp(timestamp).strftime('%H:%M:%S')

def unix_strptime_long(time_string, tz_offset):
    if time_string == None:
        return None
    d = datetime.strptime(time_string, '%Y-%m-%d %H:%M:%S')
    if tz_offset:
        return int(calendar.timegm(d.timetuple())) - tz_offset
    return int(calendar.timegm(d.timetuple()))

def unix_strptime_short(time_string):
    if time_string == None:
        return None
    d = datetime.strptime(time_string, '%H:%M:%S')
    t1 = d.timetuple()
    t2 = time.gmtime()
    return int(calendar.timegm((t2.tm_year, t2.tm_mon, t2.tm_mday,
                                t1.tm_hour, t1.tm_min, t1.tm_sec,
                                t2.tm_wday, t2.tm_yday, t2.tm_isdst)))

def unix_timestamp():
    return int(time.time())

def today_starts_unix_timestamp():
    t = time.gmtime()
    return int(calendar.timegm((t.tm_year, t.tm_mon, t.tm_mday, 0, 0, 0,
                                t.tm_wday, t.tm_yday, t.tm_isdst)))

def today_ends_unix_timestamp():
    t = time.gmtime()
    return int(calendar.timegm((t.tm_year, t.tm_mon, t.tm_mday, 23, 59, 59,
                                t.tm_wday, t.tm_yday, t.tm_isdst)))

def tz_offset():
    now = unix_timestamp()
    utc = time.gmtime(now)
    loc = time.localtime(now)
    return int(time.mktime(loc) - time.mktime(utc))

def timestamp_shift(timestamp, relative):
    if relative != None:
        m = re.search('([\+\-]?)([0-9]+)([wdhm]?)([s]?)', relative)
        if m:
            if not m.group(2):
                return None
            val = int(m.group(2))
            if m.group(3) == 'w':
                step = 7 * 24 * 60 * 60
            elif m.group(3) == 'd':
                step = 24 * 60 * 60
            elif m.group(3) == 'h':
                step = 60 * 60
            elif m.group(3) == 'm':
                step = 60
            else:
                step = 1
            if m.group(4) == 's':
                timestamp = today_starts_unix_timestamp()
            if m.group(1) == '-':
                relative = timestamp - val * step
            else:
                relative = timestamp + val * step
    return relative

def cmd_handler_invalid(vjkcli, args, unknown_args):
    parser.print_help()
    sys.exit(1)

def cmd_handler_activity_list(vjkcli, args, unknown_args):
    timestamp = unix_timestamp()
    timestamp_from = timestamp_shift(timestamp, args.start)
    if timestamp_from == None:
        timestamp_from = today_starts_unix_timestamp()
    timestamp_to = timestamp_shift(timestamp, args.stop)

    reply = vjkcli.activity_list(timestamp_from, timestamp_to)
    if not reply_verify_data(reply):
        return

    timestamp_from += tz_offset()
    if timestamp_to:
        timestamp_to += tz_offset()

    if args.long:
        ts_len = 22
    else:
        ts_len = 10
    catlen = 8
    namelen = 4
    for x in reply['data']:
        catlen = max(len(x.get('category', '')), catlen)
        namelen = max(len(x.get('name', '')), namelen)

    summary = int(0)

    fmt = "{1:<{0:}}{3:<{2:}}{5:<{4:}}{7:<{6:}}{9:<{8:}}{11:<{10:}}{13:<{12:}}"
    print(fmt.format(6, 'ID',
                     (namelen + 2), 'Name',
                     catlen + 2, 'Category',
                     ts_len, 'Start',
                     ts_len, 'Stop',
                     14, 'Duration',
                     16, 'Comment'))

    #
    # When merging we're manging the name so user
    # will notice and extend stop time.
    if args.merge:
        merged = { }
        def can_merge_ts(x, y):
            for i in ['tzstart', 'tzstop', 'tsstart', 'tsstop']:
                if not x.get(i) or not y.get(i):
                    return False
            for i in ['tzstart', 'tzstop']:
                if int(x.get(i)) != int(y.get(i)):
                    return False
            return True

        for i, x in enumerate(reply['data']):
            name = x.get('name', '')
            if len(name) == 0:
                continue
            if name not in merged:
                merged[name] = [[i, x]]
            else:
                merged[name].append([i, x])

        for name in [i for i in merged.keys()]:
            if len(merged[name]) == 1:
                del merged[name]
                continue
            for i in range(1, len(merged[name])):
                x = merged[name][i][1]
                y = merged[name][i-1][1]
                if not can_merge_ts(x, y):
                    del merged[name]
                    break

        for name in [i for i in merged.keys()]:
            x = reply['data'][merged[name][0][0]]
            x['name'] += '*' # mark as merged
            x_timestamp_start = int(x.get('tsstart', 0))
            x_timestamp_stop = int(x.get('tsstop', 0))
            for i in range(1, len(merged[name])):
                y = reply['data'][merged[name][i][0]]
                y_timestamp_start = int(y.get('tsstart', 0))
                y_timestamp_stop = int(y.get('tsstop', 0))
                spent = y_timestamp_stop - y_timestamp_start
                x_timestamp_stop += spent
                y['skip'] = True
            x['tsstop'] = str(x_timestamp_stop)
            del merged[name]

    for x in reply['data']:
        if x.get('skip'):
            continue

        tz_start = int(x.get('tzstart', 0))
        timestamp_start = int(x.get('tsstart', 0))

        if (timestamp_start + tz_start) < timestamp_from:
            continue

        tz_stop = int(x.get('tzstop', 0))
        timestamp_stop = int(x.get('tsstop', 0))
        if timestamp_stop == 0:
            spent = unix_timestamp() - timestamp_start
        else:
            spent = timestamp_stop - timestamp_start
            timestamp_stop += tz_stop

        if timestamp_to and timestamp_to > timestamp_stop:
                continue

        timestamp_start += tz_start

        if args.long:
            timestamp_start_str = unix_strftime_long(timestamp_start)
            timestamp_stop_str = unix_strftime_long(timestamp_stop)
        else:
            timestamp_start_str = unix_strftime_short(timestamp_start)
            timestamp_stop_str = unix_strftime_short(timestamp_stop)

        summary += spent
        h, m, s = seconds_to_hms(spent)
        hms = "{0:04d}:{1:02d}:{2:02d}".format(h, m, s)

        print(fmt.format(6, x['id'],
                         (namelen + 2), x.get('name', ''),
                         catlen + 2, x.get('category', ''),
                         ts_len, timestamp_start_str,
                         ts_len, timestamp_stop_str,
                         14, hms,
                         16, x.get('comment', '')))

    if args.summary:
        h, m, s = seconds_to_hms(summary)
        hms = "{0:04d}:{1:02d}:{2:02d}".format(h, m, s)
        print("---\nSummary: %s" % (hms))

def cmd_handler_category_list(vjkcli, args, unknown_args):
    reply = vjkcli.category_list()
    if not reply_verify_data(reply):
        return

    catlen = 8
    for x in reply['data']:
        catlen = max(len(x.get('category', '')), catlen)

    fmt = "{1:<{0:}}{3:<{2:}}"
    print(fmt.format(6, 'ID', catlen + 2, 'Category'))

    for x in reply['data']:
        print(fmt.format(6, x.get('id', ''),
                         catlen + 2, x.get('category','')))

def cmd_handler_delete_record(vjkcli, args, unknown_args):
    if args.category:
        vjkcli.category_delete(int(args.id))
    else:
        vjkcli.activity_delete(int(args.id))

def cmd_handler_server_exit(vjkcli, args, unknown_args):
    vjkcli.server_exit()

def parse_activity_argument(arg):
    # activity@category|comment
    m = re.match("([^\@]+)\@([^\,]+)(\,.+)?", arg)
    if m == None or m.group(1) == None or m.group(2) == None:
        return (None, None, None)
    comment = m.group(3)
    if comment != None:
        comment = m.group(3)[1:]
    return (m.group(1), m.group(2), comment)

def cmd_handler_activity_start(vjkcli, args, unknown_args):
    last_rec = vjkcli.activity_last()
    if len(last_rec.get('data',[])):
        tsstop = last_rec['data'][0].get('tsstop')
        if not tsstop:
            logging.error("Found an unfinished activity, stop it first")
            return
    if len(unknown_args) < 1:
        logging.error("Not enough arguments provided")
        return
    activity, category, comment = parse_activity_argument(unknown_args[0])
    if activity == None:
        logging.error("Wrong activity format")
        return
    vjkcli.activity_add(unix_timestamp(), tz_offset(), None, None,
                        activity, category, comment)

def cmd_handler_activity_stop(vjkcli, args, unknown_args):
    vjkcli.activity_stop(unix_timestamp(), tz_offset())
    return

def cmd_handler_activity_restart(vjkcli, args, unknown_args):
    last_rec = vjkcli.activity_last()
    if 'data' not in last_rec or len(last_rec['data']) < 1:
        logging.error("Can't fetch data")
        return
    rec  = last_rec['data'][0].get('name', '') + "@" + \
        last_rec['data'][0].get('category', '')
    comment = last_rec['data'][0].get('comment')
    if comment:
        rec += "," + comment
    cmd_handler_activity_start(vjkcli, args, [rec])

def cmd_handler_activity_add(vjkcli, args, unknown_args):
    if len(unknown_args) < 1 or args.start == None:
        logging.error("Not enough arguments provided")
        return
    activity, category, comment = parse_activity_argument(unknown_args[0])
    if activity == None:
        logging.error("Wrong activity format")
        return

    if args.tz_start:
        tz_start = int(args.tz_start)
    else:
        tz_start = tz_offset()

    if args.tz_stop:
       tz_stop  = int(args.tz_stop)
    else:
       tz_stop  = tz_offset()

    ts_start = unix_strptime_long(args.start, tz_start)
    ts_stop = unix_strptime_long(args.stop, tz_stop)

    if ts_stop == None:
        tz_stop = None

    vjkcli.activity_add(ts_start, tz_start, ts_stop, tz_stop,
                        activity, category, comment)

def cmd_handler_category_add(vjkcli, args, unknown_args):
    if len(unknown_args) < 1:
        logging.error("Not enough arguments provided")
        return
    vjkcli.category_add(unknown_args[0])

def cmd_handler_activity_edit(vjkcli, args, unknown_args):
    if len(unknown_args) > 0:
        activity, category, comment = parse_activity_argument(unknown_args[0])
    else:
        activity, category, comment = (None, None, None)

    if args.tz_start:
        args.tz_start = int(args.tz_start)
    else:
        args.tz_start = tz_offset()

    if args.tz_stop:
        args.tz_stop = int(args.tz_stop)
    else:
        args.tz_stop = tz_offset()

    args.start = unix_strptime_long(args.start, args.tz_start)
    args.stop = unix_strptime_long(args.stop, args.tz_stop)

    if not args.stop:
        args.tz_stop = None

    vjkcli.activity_update(args.id, args.start, args.tz_start,
                           args.stop, args.tz_stop,
                           activity, category, comment)

def cmd_handler_category_edit(vjkcli, args, unknown_args):
    if len(unknown_args) < 1:
        logging.error("Not enough arguments provided")
        return
    vjkcli.category_update(args.id, unknown_args[0])

cmd_handler = {
    'list':     [True, cmd_handler_activity_list, cmd_handler_category_list],
    'delete':   [True, cmd_handler_delete_record, cmd_handler_delete_record],
    'exit':     [False, cmd_handler_server_exit, cmd_handler_invalid],
    'start':    [False, cmd_handler_activity_start, cmd_handler_invalid],
    'restart':  [False, cmd_handler_activity_restart, cmd_handler_invalid],
    'stop':     [False, cmd_handler_activity_stop, cmd_handler_invalid],
    'add':      [True, cmd_handler_activity_add, cmd_handler_category_add],
    'edit':     [True, cmd_handler_activity_edit, cmd_handler_category_edit],
}


vjkcli = vjk.Vjk(logging, conf)
if vjkcli.connected() == False:
    logging.error("Not connected")
    sys.exit(1)

if args.cmd in cmd_handler:
    if cmd_handler[args.cmd][0]:
        if args.category:
            cmd_handler[args.cmd][2](vjkcli, args, unknown_args)
        else:
            cmd_handler[args.cmd][1](vjkcli, args, unknown_args)
    else:
        cmd_handler[args.cmd][1](vjkcli, args, unknown_args)

vjkcli.fini()
